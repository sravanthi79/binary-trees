//All important concepts of a tree
#include<bits/stdc++.h>
#include<queue>
using namespace std;
struct Node
{
    int data;
    struct Node *left;
    struct Node * right;
};
struct Node* getNewNode(int a)
{
    struct Node *temp=new Node();
    temp->data = a;
    temp->left=NULL;
    temp->right=NULL;
    return temp;
}
struct Node* insert(struct Node* root, int a)
{
    if(root==NULL)
        root=getNewNode(a);
    else if(a<=root->data)
        root->left=insert(root->left,a);
    else
        root->right=insert(root->right,a);
    return root;
}
bool search(struct Node* root, int sn)
{
    if(sn==root->data)
    return true;
    else if(sn<root->data)
    search(root->left,sn);
    else
    search(root->right,sn);
    return false;
}
int FindMax(struct Node* root)
{
    if(root==NULL)
    {
        cout<<"Tree is empty"<<endl;
        return -1;
    }
    while(root->right!=NULL)
    {
        root=root->right;
    }
    return root->data;
}
int FindMin(struct Node* root)
{
    if(root==NULL)
    {
        cout<<"Tree is empty"<<endl;
        return -1;
    }
    while(root->left!=NULL)
    {
        root=root->left;
    }
    return root->data;
}
int height(struct Node* root)
{
    if(root==NULL)
    return -1;
    return max(height(root->left),height(root->right))+1;
}
void levelOrderTraversal(struct Node* root)
{
    if(root==NULL)
    return;
    queue<Node*> Q;
    Q.push(root);
    while(!Q.empty())
    {
        Node* temp=Q.front();
        Q.pop();
        cout<<temp->data<<endl;
        if(temp->left)Q.push(temp->left);
        if(temp->right)Q.push(temp->right);
    }
}
void preOrder(struct Node* root)
{
    if(root==NULL)
    return;
    cout<<root->data;
    preOrder(root->left);
    preOrder(root->right);
}
void inOrder(struct Node* root)
{
    if(root==NULL)
    return;
    inOrder(root->left);
    cout<<root->data;
    inOrder(root->right);
}
void postOrder(struct Node* root)
{
    if(root==NULL)
    return;
    postOrder(root->left);
    postOrder(root->right);
    cout<<root->data;
}
bool isBst(struct Node* root, struct Node* l, struct Node* r)
{
    if(root==NULL)
    return true;
    if(l!=NULL && root->data<l->data)
    return false;
    if(r!=NULL && root->data>r->data)
    return false;
    return isBst(root->left, l, root) && isBst(root->right, root, r);
}
struct Node* Delete(struct Node* root, int val)
{
    if(root==NULL)
    return root;
    else if(val<root->data)
    root->left=Delete(root->left,val);
    else if(val>root->data)
    root->right=Delete(root->right,val);
    else
    {
        if(root->left==NULL && root->right==NULL)
        {
        delete root;
        root=NULL;
        }
        else if (root->left == NULL) {
        Node* temp = root;
        root=root->right;
        delete temp;
        }
        else if (root->right == NULL) {
        Node* temp = root;
        root=root->left;
        delete temp;
        }
        else
        {
            Node* succParent = root;
            Node* succ = root->right;
            while (succ->left != NULL) 
            {
            succParent = succ;
            succ = succ->left;
            }
            if (succParent != root)
            succParent->left = succ->right;
            else
            succParent->right = succ->right;
            
            root->data = succ->data;
            delete succ;
            return root;
        }
    }
}
struct Node* find(struct Node* root, int num)
{
    if(root==NULL)
    return NULL;
    else if(root->data==num)
    return root;
    else if(num<root->data)
    return find(root->left, num);
    else return find(root->right, num);
}
int InorderSuccessor(struct Node* root, int num)
{
  struct Node *curr=NULL;
  curr=find(root,num);
  if(curr==NULL)
  return -1;
  if(curr->right!=NULL)
  {
      return FindMin(curr->right);
  }
  else
  {
      struct Node* successor=NULL;
      struct Node* ancestor=root;
      while(ancestor!=curr)
      {
          if(curr->data<ancestor->data)
          {
              successor=ancestor;
              ancestor=ancestor->left;
          }
          else ancestor=ancestor->right;
      }
     return successor->data;
  }
}
int main()
{
    struct Node *root=NULL;
    int n;
    cin>>n;
    int a;
    while(n--)
    {
        cin>>a;
        root=insert(root,a);
    }
    int search_number;
    cin>>search_number;
    if(search(root,search_number)) 
    cout<<"found"<<endl;
    else
    cout<<"No number found"<<endl;
    cout<<FindMin(root)<<" is the min element in the BST"<<endl;
    cout<<FindMax(root)<<" is the max element in the BST"<<endl;
    cout<<height(root)<<" is the height of the tree"<<endl;
    cout<<"Level Order Traversal of the tree is"<<endl;
    levelOrderTraversal(root);
    cout<<"The preorder traversal of the tree is"<<endl;
    preOrder(root);
    cout<<"The inorder traversal of the tree is"<<endl;
    inOrder(root);
    cout<<"The postorder traversal of the tree is"<<endl;
    postOrder(root);
    if(isBst(root, NULL,NULL))
    cout<<"Given tree is a Binary Search Tree"<<endl;
    else
    cout<<"Given tree is not a Binary Search Tree"<<endl;
    int number;
    cin>>number;
    root=Delete(root,number);
    cout<<"The inorder traversal of the tree is"<<endl;
    inOrder(root);
    cin>>number;
    cout<<InorderSuccessor(root, number)<<"is the inorder successor"<<endl;
    return 0;
}
